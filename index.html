<link rel="stylesheet" href="style.css">

<style>
  .player {
    fill: green;
    stroke: black;
    vector-effect: non-scaling-stroke;
  }
  .enemy {
    fill: darkcyan;
    stroke: black;
    vector-effect: non-scaling-stroke;
  }
  .flame {
    filter: blur( 10px );
    mix-blend-mode: screen;
  }
  .debris {
    fill: green;
    stroke: black;
  }
</style>

<body>
  <svg id="svg" width="2000px" height="2000px" style="background-color: #111;">
    <defs>
      <path id="player" class="player" d="M 1.0 0 L 0.5 0.3 L -0.2 0.4 L -0.6 0.9 L -1.0 1.0 L -1.0 -1.0 L -0.6 -0.9 L -0.2 -0.4 L 0.5 -0.3 Z"></path>
      <path id="enemy"  class="enemy"  d="M 1.0 0 L 0.5 0.3 L  0.0 0.4 L -0.6 0.9 L -1.0 1.0 L -1.0 -1.0 L -0.6 -0.9 L  0.0 -0.4 L 0.5 -0.3 Z"></path>
    </defs>
    <g id="stars"></g>
  </svg>
</body>

<script type="module">

  import { Ship } from './src/ship.js';

  const SVGNS = 'http://www.w3.org/2000/svg';

  // Create starfield
  const stars = document.getElementById( 'stars' );
  for ( let i = 0; i < 300; i ++ ) {
    const star = document.createElementNS( SVGNS, 'circle' );
    star.setAttribute( 'cx', Math.floor( Math.random() * 2000 ) + 0.5 );
    star.setAttribute( 'cy', Math.floor( Math.random() * 2000 ) + 0.5 );
    star.setAttribute( 'r',  Math.random() * 1 );

    const col = Math.random() * 50 + 200;
    star.setAttribute( 'fill', `rgba( ${ col }, ${ col }, ${ col }, ${ Math.random() } )` );
    stars.appendChild( star );
  }

  let player = new Ship( 'player' );
  let enemies = Array.from( Array( 10 ), _ => new Ship( 'enemy' ) );
  let ships = [ player, ...enemies ];

  ships.forEach( ship => spawn( ship ) );

  function spawn( entity ) {
    // TODO: Avoid existing entities?
    entity.x = Math.random() * 2000;
    entity.y = Math.random() * 2000;
    entity.angle = Math.random() * Math.PI * 2;
  }

  function update( dt ) {
    player.goalAngle = Math.atan2( 
      document.body.scrollTop + mouseY - player.y, 
      document.body.scrollLeft + mouseX - player.x
    );
    enemies.forEach( enemy => enemy.think( player, ships ) );
    
    ships.forEach( ship => ship.update( dt ) );

    ships = ships.filter( ship => {
      ships.forEach( other => {
        if ( ship != other && Math.hypot( ship.x - other.x, ship.y - other.y ) < ship.size + other.size ) {
          ship.life -= other.damage;
        }
      } );

      if ( ship.life <= 0 ) {
        ship.die();
        return false;
      }
      else {
        return true;
      }
    } );

    document.body.scrollTo( player.x - window.innerWidth / 2, player.y - window.innerHeight / 2 );
  }


  //
  // Input and update loop
  //

  let mouseX = 0, mouseY = 0, mouseDown = false;
  document.onmousemove = onInput;
  document.ontouchmove = onInput;
  document.onmousedown  = ( e ) => { mouseDown = true; onInput( e ); }
  document.ontouchstart = ( e ) => { mouseDown = true; onInput( e ); }
  document.onmouseup  = ( e ) => mouseDown = false;
  document.ontouchend = ( e ) => mouseDown = false;
  function onInput( e ) {
    const event = e.touches ? e.touches[0] : e;
    mouseX = event.clientX;
    mouseY = event.clientY;
  }

  let lastTime = null;
  function animate( now ) {
    lastTime ??= now;   // for first call only
    update( now - lastTime );
    lastTime = now;

    requestAnimationFrame( animate );
  }
  requestAnimationFrame( animate );

</script>