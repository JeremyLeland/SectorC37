<title>Follow the Mouse</title>
<link rel="stylesheet" href="../grid.css">

<script type="module">
  import { AnimatedCanvas } from '../src/AnimatedCanvas.js';
  import { EntitySimulator } from './EntitySimulator.js';
  import { ValuesPanel } from './ValuesPanel.js';
  import { Entity } from '../src/Entity.js';
  import { AvoidCones } from '../src/AvoidCones.js';
  import * as Util from '../src/Util.js';

  
  function shipPath() {
    const path = new Path2D();
    path.moveTo( 1, 0 );
    path.arc( 0, 0, 1, 2.2, -2.2 );
    path.closePath();
    return path;
  }

  function rockPath() {
    const path = new Path2D();
    path.arc( 0, 0, 1, 0, Math.PI * 2 );
    return path;
  }

  class Ship extends Entity {
    type = 'ship';
    size = 16;
    // color = 'green';
    drawPath = shipPath();
    turnSpeed = 0.005;
    moveSpeed = 0.05;
    avoids = [ 'rock' ];
    aligns = [ 'ship' ];

    update( dt ) {
      if ( dt > 0 ) {

        const goalTurn = Util.deltaAngle( this.angle, this.goalAngle );
        const turn = Math.min( Math.abs( goalTurn ), this.turnSpeed * dt );
        this.angle += Math.sign( goalTurn ) * turn;
        this.angle = Util.fixAngle( this.angle );
        
        this.x += Math.cos( this.angle ) * this.moveSpeed * dt;
        this.y += Math.sin( this.angle ) * this.moveSpeed * dt;
        
        // super.update( dt );
      }
    }
  }

  class Rock extends Entity {
    type = 'rock';
    size = 30;
    color = 'brown';
    drawPath = rockPath();
  }

  const entities = [
    // new Ship( { x: 200, y: 200, angle:  1, color: 'red' } ),
    // new Ship( { x: 250, y: 250, angle:  0, color: 'orange' } ),
    // new Ship( { x: 200, y: 300, angle: -1, color: 'yellow' } ),
    // new Ship( { x: 600, y: 280, angle:  0, color: 'salmon' } ),
    // new Ship( { x: 600, y: 310, angle:  0, color: 'maroon' } ),
    // new Ship( { x: 100, y: 300, angle: -1, color: 'pink' } ),
    // new Rock( { x: 400, y: 250 } ),
    // new Rock( { x: 400, y: 320 } ),
    // new Rock( { x: 400, y: 390 } ),

    new Ship( { x: 400, y: 400, angle: 0, color: randomColor() } ),
    new Rock( { x: 150, y: 350 } ),
    new Rock( { x: 250, y: 450 } ),
    new Rock( { x: 350, y: 500 } ),
  ];

  const Constants = {
    AvoidDistance: 100,
    TargetWeight: 0.25,
    AlignWeight: 5,
    AvoidWeight: 2,
    UIScale: 100,
  };

  new ValuesPanel( Constants ).valueChanged = refresh;
  new EntitySimulator( entities ).onInput = refresh;

  const canvas = new AnimatedCanvas();

  let target = { x: 500, y: 300 };

  canvas.update = ( dt ) => {
    entities.forEach( entity => {

      entity.vectors = [];

      const targetWeight = Constants.TargetWeight;
      const targetAngle = Math.atan2( target.y - entity.y, target.x - entity.x );
      entity.vectors.push( {
        x: Math.cos( targetAngle ) * targetWeight,
        y: Math.sin( targetAngle ) * targetWeight,
        src: { color: 'gray' },
      } );

      if ( entity.aligns ) {
        entities.filter( e => e != entity && entity.aligns.includes( e.type ) ).forEach( other => {
          const cx = other.x - entity.x;
          const cy = other.y - entity.y;
          const dist = Math.max( 0.1, Math.hypot( cx, cy ) - entity.size - other.size );
          const angle = Math.atan2( cy, cx );

          const avoidWeight = Constants.AvoidWeight / dist;
          entity.vectors.push( {
            x: -Math.cos( angle ) * avoidWeight,
            y: -Math.sin( angle ) * avoidWeight,
            src: other,
          } );

          const alignWeight = Constants.AlignWeight / dist;
          const averageAngle = entity.angle + Util.deltaAngle( entity.angle, other.angle ) / 2;
          
          entity.vectors.push ( {
            x: Math.cos( averageAngle ) * alignWeight,
            y: Math.sin( averageAngle ) * alignWeight,
            src: other,
          } );
        } );
      }

      if ( entity.vectors.length > 0 ) {
        entity.totalVector = entity.vectors.reduce( ( a, b ) => ( { x: a.x + b.x, y: a.y + b.y } ), { x: 0, y: 0 } );
        entity.goalAngle = Math.atan2( entity.totalVector.y, entity.totalVector.x );
      }
      else {
        entity.totalVector = null;
        entity.goalAngle = entity.angle;
      }

      if ( entity.avoids ) {
        entity.avoidCones = new AvoidCones();
        entities.filter( e => e != entity && entity.avoids.includes( e.type ) ).forEach( other => {
          const cx = other.x - entity.x;
          const cy = other.y - entity.y;
          const dist = Math.hypot( cx, cy );
          
          if ( dist < Constants.AvoidDistance ) {
            const angle = Math.atan2( cy, cx );
          
            const r = entity.size + other.size + 10;
            const h = dist;
            const spread = Math.asin( Math.min( 1, r / h ) );   // min() prevents floating errors when we get really close

            entity.avoidCones.addCone( { left: angle - spread, right: angle + spread } );
          }
        } );

        const goalCone = entity.avoidCones.getCone( entity.goalAngle );

        if ( goalCone ) {
          entity.goalAngle = Util.closestAngle( entity.angle, goalCone.left, goalCone.right );
        }
      }
    } );

    entities.forEach( entity => entity.update( dt ) );
  };
  
  canvas.draw = ( ctx ) => {
    entities.forEach( entity => entity.draw( ctx ) );

    // Avoid cones
    entities.forEach( entity => {
      ctx.strokeStyle = 'gray';
      ctx.beginPath();
      ctx.moveTo( target.x, target.y );
      ctx.lineTo( entity.x, entity.y );
      ctx.setLineDash( [ 5, 5 ] );
      ctx.stroke();
      ctx.setLineDash( [] );

      ctx.save();
      ctx.translate( entity.x, entity.y );

      if ( entity.avoidCones ) {
        ctx.fillStyle = entity.color;
        ctx.strokeStyle = 'white';
        entity.avoidCones.draw( ctx, Constants.UIScale );
      }
      
      drawVector( entity.totalVector, ctx, 'white' );
      if ( entity.alignVector )   drawVector( entity.alignVector, ctx, 'green' );
      entity.vectors?.forEach( v => drawVector( v, ctx, v.src.color ) );

      ctx.beginPath();
      ctx.moveTo( 0, 0 );
      ctx.lineTo( Math.cos( entity.goalAngle ) * Constants.UIScale, Math.sin( entity.goalAngle ) * Constants.UIScale );
      ctx.stroke();

      ctx.restore();
    } );
  };

  function drawVector( vector, ctx, color = 'white' ) {
    if ( !vector )  return;

    const x = vector.x * Constants.UIScale;
    const y = vector.y * Constants.UIScale;
    const angle = Math.atan2( y, x );

    ctx.strokeStyle = ctx.fillStyle = color;
    
    ctx.beginPath();
    ctx.moveTo( 0, 0 );
    ctx.lineTo( x, y );
    
    ctx.stroke();
    
    // TODO: Combine w/above?

    const HEAD_LENGTH = 5;
    const HEAD_WIDTH = 2.5;
    ctx.beginPath();
    ctx.moveTo( x, y );
    ctx.arc( x, y, HEAD_LENGTH, angle + HEAD_WIDTH, angle - HEAD_WIDTH );
    ctx.fill();
  }
 
  // canvas.start();

  function refresh() {
    canvas.update( 0 );
    canvas.redraw();
  }
  
  refresh();

  function randomColor() {
    return `hsl( ${ Math.random() * 360 }deg, ${ Math.random() * 50 + 25 }%, ${ Math.random() * 50 + 25 }% )`;
  }

  function randomBrown() {
    return `hsl( ${ 30 + Math.random() * 10 }deg, ${ Math.random() * 25 + 75 }%, ${ Math.random() * 25 }% )`;
  }

  let mouseX = 0, mouseY = 0;

  document.addEventListener( 'keydown', ( e ) => {
    if ( e.key == 's' ) {
      entities.push( new Ship( { x: mouseX, y: mouseY, color: randomColor() } ) );
    }
    if ( e.key == 'r' ) {
      entities.push( new Rock( { x: mouseX, y: mouseY } ) );
    }
    else {
      canvas.update( 30 );
    }
    
    canvas.update( 0 );
    canvas.redraw();
  } );
  
  document.addEventListener( 'mousedown', ( e ) => {
    target = { x: e.clientX, y: e.clientY };
  } );

  document.addEventListener( 'mousemove', ( e ) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
  } );
  
</script>