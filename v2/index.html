<title>Sector C37</title>
<link rel="stylesheet" href="./grid.css">

<script type="module">
  import { AnimatedCanvas } from './src/AnimatedCanvas.js';
  import { World } from './src/World.js';
  import { Starfield } from './src/Starfield.js';
  import { Player, Ship, Rock } from './src/SectorC37.js';
  import * as Util from './src/Util.js';

  const PLAYER_RESPAWN_DELAY = 2000;
  let playerSpawnTimer = PLAYER_RESPAWN_DELAY;

  let player = new Player( { x: 0, y: 0, angle: 0 } );

  const world = new World( 1000 );
  world.entities = [ player ];

  const numRocks = 10, rockSpacing = 300;
  for ( let i = 0; i < numRocks; i ++ ) {
    for ( let d = 1; d < world.size / rockSpacing; d ++ ) {
      const angle = Math.PI * 2 * ( i + 0.25 + 0.5 * Math.random() ) / numRocks;
      const dist = rockSpacing * ( d + 0.25 + 0.5 * Math.random() );
      world.entities.push( new Rock( { 
        x: Math.cos( angle ) * dist, 
        y: Math.sin( angle ) * dist,
        angle: Math.random() * Math.PI * 2,
        dx: 0.1 * ( Math.random() - 0.5 ),
        dy: 0.1 * ( Math.random() - 0.5 ),
        dAngle: 0.004 * ( Math.random() - 0.5 ),
        size: 10 + Math.random() * 50,
      } ) );
    }
  }

  const numShips = 10, shipSpacing = 200;
  for ( let i = 0; i < numShips; i ++ ) {
    const angle = Math.PI * 2 * ( i + 0.25 + 0.5 * Math.random() ) / numShips;
    const dist = world.size + shipSpacing * ( 0.25 + 0.5 * Math.random() );
    const ship = new Ship( { 
      x: Math.cos( angle ) * world.size,
      y: Math.sin( angle ) * world.size,
      angle: Math.random() * Math.PI * 2,
    } );

    ship.target = player;

    world.entities.push( ship );
  }

  const starfield = new Starfield( world.size * 2, world.size * 2 , 1000, 2 );

  let scrollX = 0, scrollY = 0;

  const canvas = new AnimatedCanvas();

  canvas.update = ( dt ) => {
    if ( player.isAlive ) {  
      scrollX = Math.min( world.size, Math.max( window.innerWidth - world.size, window.innerWidth / 2 - player.x ) );
      scrollY = Math.min( world.size, Math.max( window.innerHeight - world.size, window.innerHeight / 2 - player.y ) );

      player.target = { x: mouseX - scrollX, y: mouseY - scrollY };
    }
    else {
      playerSpawnTimer -= dt;
    }

    world.update( dt );

    // Keep rocks inside world (TODO: wrap around instead of bounce?)
    world.entities.filter( e => e instanceof Rock ).forEach( rock => {
      if ( rock.x + rock.size < -world.size || rock.x - rock.size > world.size )  rock.dx = -rock.dx;
      if ( rock.y + rock.size < -world.size || rock.y - rock.size > world.size )  rock.dy = -rock.dy;
    } );
  };
  
  canvas.draw = ( ctx ) => {
    starfield.draw( ctx, scrollX, scrollY );

    ctx.save();
    ctx.translate( scrollX, scrollY );
    world.draw( ctx );

    // ctx.beginPath();
    
    // for ( let d = 1; d < world.size / rockSpacing; d ++ ) {
    //   ctx.arc( 0, 0, rockSpacing * d, 0, Math.PI * 2 );
    // }

    // for ( let i = 0; i < numRocks; i ++ ) {
    //   const angle = Math.PI * 2 * i / numRocks;
    //   ctx.moveTo( 0, 0 );
    //   ctx.lineTo( Math.cos( angle ) * world.size, Math.sin( angle ) * world.size );
    // }
    
    // ctx.stroke();

    ctx.restore();
  };

  canvas.start();

  let mouseX = 0, mouseY = 0;

  document.addEventListener( 'keydown', ( e ) => {
    if ( e.key == 'Control' )   player.isSliding = true;
  } );

  document.addEventListener( 'keyup', ( e ) => {
    if ( e.key == 'Control' )   player.isSliding = false;
  } );
  
  document.addEventListener( 'mousedown', ( e ) => {
    if ( player.isAlive ) {
      player.isShooting = true;
    }
    else if ( playerSpawnTimer < 0 ) {
      playerSpawnTimer = PLAYER_RESPAWN_DELAY;
      player = new Player( { x: 0, y: 0, angle: 0 } );
      world.entities.push( player );
    }
  } );
  document.addEventListener( 'mouseup',   ( e ) => player.isShooting = false );
  document.addEventListener( 'mousemove', ( e ) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
  } );
  
</script>