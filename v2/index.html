<title>Sector C37</title>
<link rel="stylesheet" href="./grid.css">

<style>
  body { cursor: crosshair; }

  #ui {
    position: absolute;
    vertical-align: top;
    display: flex;
    gap: 8px;
    margin-left: 4px;
  }

  .outer_bar {
    width: 150px;
    height: 8px;
    margin-top: 5px;
    border: 1px solid white;
  }

  .inner_bar {
    height: 100%;
  }

  #health { background-color: rgba( 255, 0, 0, 0.5 ); }
  #energy { background-color: rgba( 0, 200, 255, 0.5 ); }
  #minimap { background-color: rgba( 20, 20, 20, 0.5 ); }
</style>

<body>
  <div id="ui">
    Health:
    <div class="outer_bar">
      <div class="inner_bar" id="health"></div>
    </div>
    Energy:
    <div class="outer_bar">
      <div class="inner_bar" id="energy"></div>
    </div>
    <canvas id="minimap" width="100" height="100"></canvas>
    <label for="enemies">Enemies: </label>
    <span id="enemies"></span>
  </div>
</body>

<script type="module">
  import { AnimatedCanvas } from './src/AnimatedCanvas.js';
  import { World } from './src/World.js';
  import { Starfield } from './src/Starfield.js';
  import { Player, Ship, Rock } from './src/SectorC37.js';
  import * as Util from './src/Util.js';

  const healthUI = document.getElementById( 'health' );
  const energyUI = document.getElementById( 'energy' );
  const minimapCtx = document.getElementById( 'minimap' ).getContext( '2d' );
  const enemiesUI = document.getElementById( 'enemies' );

  const PLAYER_RESPAWN_DELAY = 2000;
  let playerSpawnTimer = PLAYER_RESPAWN_DELAY;

  const ENEMY_SPAWN_DELAY = 5000;
  let enemySpawnTimer = ENEMY_SPAWN_DELAY;

  let player = new Player( { x: 0, y: 0, angle: 0 } );

  const world = new World( 1000 );
  world.entities = [ player ];

  const numRocks = 10, rockSpacing = 300;
  for ( let i = 0; i < numRocks; i ++ ) {
    for ( let d = 1; d < world.size / rockSpacing; d ++ ) {
      const angle = Math.PI * 2 * ( i + 0.25 + 0.5 * Math.random() ) / numRocks;
      const dist = rockSpacing * ( d + 0.25 + 0.5 * Math.random() );
      world.entities.push( new Rock( { 
        x: Math.cos( angle ) * dist, 
        y: Math.sin( angle ) * dist,
        angle: Math.random() * Math.PI * 2,
        dx: 0.1 * ( Math.random() - 0.5 ),
        dy: 0.1 * ( Math.random() - 0.5 ),
        dAngle: 0.004 * ( Math.random() - 0.5 ),
        size: 10 + Math.random() * 50,
      } ) );
    }
  }

  const numShips = 10, shipSpacing = 200;
  for ( let i = 0; i < numShips; i ++ ) {
    const angle = Math.PI * 2 * ( i + 0.25 + 0.5 * Math.random() ) / numShips;
    const dist = world.size + shipSpacing * ( 0.25 + 0.5 * Math.random() );
    spawnShip( angle, dist );
  }

  function spawnShip( angle, dist ) {
    world.entities.push( 
      new Ship( { 
        x: Math.cos( angle ) * dist,
        y: Math.sin( angle ) * dist,
        angle: Math.random() * Math.PI * 2,
      } )
    );
  }

  const starfield = new Starfield( world.size * 2, world.size * 2 , 1000, 2 );

  let scrollX = 0, scrollY = 0;

  const canvas = new AnimatedCanvas();

  canvas.update = ( dt ) => {
    if ( player.isAlive ) {  
      scrollX = Math.min( world.size, Math.max( window.innerWidth - world.size, window.innerWidth / 2 - player.x ) );
      scrollY = Math.min( world.size, Math.max( window.innerHeight - world.size, window.innerHeight / 2 - player.y ) );

      player.targetGoal = { x: mouseX - scrollX, y: mouseY - scrollY };
    }
    else {
      playerSpawnTimer -= dt;
    }

    if ( ( enemySpawnTimer -= dt ) < 0 ) {
      enemySpawnTimer += ENEMY_SPAWN_DELAY;
      spawnShip( Math.random() * Math.PI * 2, world.size + 100 * Math.random() );
    }

    world.update( dt );

    // Keep rocks inside world (TODO: wrap around instead of bounce?)
    world.entities.filter( e => e instanceof Rock ).forEach( rock => {
      if ( rock.x + rock.size < -world.size || rock.x - rock.size > world.size )  rock.dx = -rock.dx;
      if ( rock.y + rock.size < -world.size || rock.y - rock.size > world.size )  rock.dy = -rock.dy;
    } );
  };
  
  canvas.draw = ( ctx ) => {
    starfield.draw( ctx, scrollX, scrollY );

    ctx.save();
    ctx.translate( scrollX, scrollY );
    world.draw( ctx );

    // ctx.beginPath();
    
    // for ( let d = 1; d < world.size / rockSpacing; d ++ ) {
    //   ctx.arc( 0, 0, rockSpacing * d, 0, Math.PI * 2 );
    // }

    // for ( let i = 0; i < numRocks; i ++ ) {
    //   const angle = Math.PI * 2 * i / numRocks;
    //   ctx.moveTo( 0, 0 );
    //   ctx.lineTo( Math.cos( angle ) * world.size, Math.sin( angle ) * world.size );
    // }
    
    // ctx.stroke();

    ctx.restore();

    healthUI.style.width = `${ 100 * Math.max( 0, player.life ) / player.maxLife }%`;
    energyUI.style.width = `${ 100 * Math.max( 0, player.energy ) / player.maxEnergy }%`;

    drawMinimap( minimapCtx );

    const numEnemies = world.entities.filter( e => e instanceof Ship ).length;
    enemiesUI.innerText = numEnemies;
  };

  function drawMinimap( ctx ) {
    // Assume a square minimap
    const scale = ctx.canvas.width / ( world.size * 2 );

    ctx.clearRect( 0, 0, ctx.canvas.width, ctx.canvas.height );

    ctx.save();
    ctx.translate( ctx.canvas.width / 2, ctx.canvas.height / 2 );
    ctx.scale( scale, scale );
    
    // world.entities.filter( e => e.size > 8 ).forEach( e => {
    world.entities.filter( e => e.boundingLines ).forEach( e => {
      ctx.beginPath();
      ctx.arc( e.x, e.y, e.size, 0, Math.PI * 2 );
      ctx.fillStyle = e.color;
      ctx.fill();
    } );

    ctx.restore();
  }

  canvas.start();

  let mouseX = 0, mouseY = 0;

  document.addEventListener( 'keydown', ( e ) => {
    if ( e.key == 'Control' )   player.isSliding   = true;
    if ( e.key == 'Shift'   )   player.isSprinting = true;
  } );

  document.addEventListener( 'keyup', ( e ) => {
    if ( e.key == 'Control' )   player.isSliding   = false;
    if ( e.key == 'Shift'   )   player.isSprinting = false;
  } );
  
  document.addEventListener( 'mousedown', ( e ) => {
    if ( player.isAlive ) {
      player.isShooting = true;
    }
    else if ( playerSpawnTimer < 0 ) {
      playerSpawnTimer = PLAYER_RESPAWN_DELAY;
      player = new Player( { x: 0, y: 0, angle: 0 } );
      world.entities.push( player );
    }
  } );
  document.addEventListener( 'mouseup',   ( e ) => player.isShooting = false );
  document.addEventListener( 'mousemove', ( e ) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
  } );
  
</script>